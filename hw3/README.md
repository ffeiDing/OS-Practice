# 第三次作业
## 一、安装配置Docker

安装成功后，docker服务端和docker客户端版本信息如下图：

<div align=left><img width="50%" height="50%" src="https://github.com/ffeiDing/OS-Practice/blob/master/hw3/docker版本信息截图.png"/></div>

## 二、docker基本命令
### 1、镜像管理
* 列出镜像 
```
docker images [OPTIONS] [REPOSITORY]
参数:
-a, --all=false                  列出所有镜像（默认隐藏中间镜像）
--digests=falseShow digests      摘要
-f, --filter=[]                  根据条件过滤输出
--help=false                     打印使用帮助
--no-trunc=false                 不缩略输出          
-q, --quiet=false                仅显示数字标识符
```
>例子：
```
docker images
```
<div align=left><img width="80%" height="80%" src="https://github.com/ffeiDing/OS-Practice/blob/master/hw3/dockerimages指令运行截图.png"/></div>  

* 拉取镜像
```
docker pull [OPTIONS] NAME[:TAG|@DIGEST]
参数:
-a, --all-tags=false             拉取所有tagged镜像 
--help=false                     打印使用帮助
```
>例子：
```
docker pull  ubuntu:latest
docker pull  ubuntu:12.04
```
<div align=left><img width="80%" height="80%" src="https://github.com/ffeiDing/OS-Practice/blob/master/hw3/dockerpull指令运行截图.png"/></div> 

* 查找镜像
```
docker search [OPTIONS] TERM/NAME
参数:
--automated=false             仅显示自动化的builds
--help=false                  打印使用帮助
--no-trunc=false              不缩略输出 
-s, --stars=0                 只显示至少x颗星的信息（在该情况下为至少0颗星）
```
>例子：
```
docker search hello_world
```
<div align=left><img width="80%" height="80%" src="https://github.com/ffeiDing/OS-Practice/blob/master/hw3/dockersearch指令运行截图.png"/></div> 

* 构建镜像

Step 1:建立Dockerfile
```
FROM ubuntu
MAINTAINER zxp huo "likewind@gmail.com"
RUN apt-get update
RUN apt-get install -y nginx
RUN echo 'hi ,i am in container'>/usr/share/nginx/html/index.html
EXPOSE 80
```
Step 2:build建立镜像
```
docker build [OPTIONS] PATH | URL | -
参数:
-c, --cpu-shares=0    CPU shares (relative weight)
--cpuset-cpus=        CPUs in which to allow execution 
-f, --file=           Name of the Dockerfile (Default is 'PATH/Dockerfile')
--force-rm=false      Always remove intermediate containers
--help=false          Print usage
-m, --memory=         Memory limit
--memory-swap=        Total memory (memory + swap), '-1' to disable swap
--no-cache=false      Do not use cache when building the image
--pull=false          Always attempt to pull a newer version of the image
-q, --quiet=false     Suppress the verbose output generated by the containers
--rm=true             Remove intermediate containers after a successful build
-t, --tag=            Repository name (and optionally a tag) for the image(镜像名：标签)
```

### 2、容器管理

* 创建并启动容器
```
docker run [OPTIONS] IMAGE {COMMAND} [ARG...]
参数:
-d                            创建一个守护式容器在后台运行
-i                            交互式运行
-t                            为容器重新分配一个伪输入终端
-p                            指定端口或IP进行映射
--name="NAME"                 为容器指定一个名称
--network="NETWORK_NAME"      选择一个网络
```
* 查看容器
```
docker ps [OPTIONS]
参数:
-a                            查看已经创建的容器
-s                            查看已经启动的容器
```
* 启动容器
```
docker start con_name         启动容器名为con_name的容器
```
* 停止运行容器
```
docker stop con_name          停止容器名为con_name的容器
```
* 删除容器
```
docker rm con_name            删除容器名为con_name的容器
```
* 重命名容器
```
docker rename old_name new_name
```
* 容器信息
```
docker logs con_name          获取容器名为con_name的容器日志
```

### 3、网络管理
* 创建网络
```
docker network create
```
* 容器连接到网络
```
docker network connect
```
* 列出网络
```
docker network ls
```
* 删除网络
```
docker network rm
```
* 容器断开网络
```
docker network disconnect
```
* 网络信息
```
docker network inspect
```

## 三、创建一个基础镜像为ubuntu的docker镜像，随后在其中加入nginx服务器，之后启动nginx服务器并利用tail命令将访问日志输出到标准输出流。要求该镜像中的web服务器主页显示自己编辑的内容，编辑的内容包含学号和姓名。之后创建一个自己定义的network，模式为bridge，并让自己配的web服务器容器连到这一网络中。要求容器所在宿主机可以访问这个web服务器搭的网站
### 1、创建一个基础镜像为ubuntu的docker镜像
* 拉取镜像
```
sudo docker pull  ubuntu:latest
```
<div align=left><img width="80%" height="80%" src="https://github.com/ffeiDing/OS-Practice/blob/master/hw3/dockerpull指令运行截图.png"/></div> 

* 创建并启动容器
```
docker run -i -t --name ubuntu_docker -p 9999:80 ubuntu /bin/bash
```
### 2、加入nginx服务器

* 在创建的容器中安装ngix
```
apt update
apt install nginx
```
* 安装依赖包
```
apt install vim
```
* 修改主页内容
```
cd /var/www/html/
vim index.nginx-debian.html
```
* 添加转发端口号

登录燕云，添加内部9999端口至外部9999端口的转发

<div align=left><img width="80%" height="80%" src="https://github.com/ffeiDing/OS-Practice/blob/master/hw3/添加端口.png"/></div> 

* 启动nginx服务器
```
cd ..
cd ..
cd ..
nginx
```
* 浏览器访问<code> http://162.105.174.40:9999 </code>查看主页内容

<div align=left><img width="80%" height="80%" src="https://github.com/ffeiDing/OS-Practice/blob/master/hw3/web主页内容.png"/></div>

* 输出访问日志到标准输出流
```
tail -f /var/log/nginx/access.log
```
结果如下图：

<div align=left><img width="100%" height="100%" src="https://github.com/ffeiDing/OS-Practice/blob/master/hw3/访问日志.png"/></div>

### 3、创建自定义网络

* 停止容器

Ctrl C 后退回到容器
```
exit
```
停止该容器

* 保存镜像
```
docker commit ubuntu_docker ubuntu_docker2
```
* 创建并运行带新镜像的容器
```
docker run -d --name hw_docker -p 9999:80 ubuntu_docker2 nginx -g 'daemon off;'
```
* 创建一个自己定义的network，模式为bridge
```
docker network create hw_network
```
* 将容器连入网络并检查
```
docker network connect hw_network hw_docker
docker network inspect hw_network
```
下图表示成功连入

<div align=left><img width="80%" height="80%" src="https://github.com/ffeiDing/OS-Practice/blob/master/hw3/网络信息.png"/></div>

### 4、宿主机访问web服务器搭的网站

* 查看容器信息获取ip地址
```
docker inspect hw_docker
```

ip地址为172.17.0.2

* 访问web服务器网站
```
curl 172.17.0.2:80
```
<div align=left><img width="80%" height="80%" src="https://github.com/ffeiDing/OS-Practice/blob/master/hw3/访问web服务器搭的网站.png"/></div>

## 四、docker容器加入不同的网络模式
### 1、null模式
```
docker run -i -t --net="none"  mysql:latest /bin/bash
```

输入以上指令进入容器后，再输入<code>ip addr</code>，查看网络信息
<div align=left><img width="80%" height="80%" src="https://github.com/ffeiDing/OS-Practice/blob/master/hw3/null模式网络.png"/></div>

* 容器仅有一个本地回环网络<code>127.0.0.1</code>，没有任何网络配置

* 容器不能通过网络管理指令来断开null模式下的网络

### 2、bridge模式
```
docker run -i -t mysql:latest /bin/bash
docker run -i -t --net="bridge" mysql:latest /bin/bash
```

以上两个指令都可以创建bridge模式的网络下的容器，即默认情况下容器的网络配置为bridge模式，进入容器后，再输入<code>ip addr</code>，查看网络信息
<div align=left><img width="80%" height="80%" src="https://github.com/ffeiDing/OS-Practice/blob/master/hw3/bridge模式网络.png"/></div>

从上图中可以看到，容器内有一个eth0接口，解释eth0需要理解bridge桥接模式：

* Docker Daemon利用veth pair技术，在宿主机上创建两个虚拟网络接口设备，假设为veth0和veth1。veth pair技术的特性可以保证无论哪一个veth接收到网络报文，都会将报文传输给另一方

* Docker Daemon将veth0附加到Docker Daemon创建的docker0网桥上，保证宿主机的网络报文可以发往veth0

* Docker Daemon将veth1添加到容器所属的<code>namespace</code>下，并被改名为eth0。

* 宿主机的网络报文若发往veth0，则立即会被eth0接收，实现宿主机到容器网络的联通性；同时，也保证Docker Container单独使用eth0，实现容器网络环境的隔离性

* bridge模式的网络可以创建多个

* 容器可以通过网络管理指令来断开bridge模式下的网络或连接其他网络

### 3、host模式
```
docker run -i -t --net="host" mysql:latest /bin/bash
```

该模式区别于bridge模式，在无需进行NAT转换的同时，隔离性弱化了：

* 容器不需要通过桥接模式，可以直接访问宿主机上的全部网络信息，不会有所属的<code>namespace</code>，而是共享宿主机的<code>namespace</code>

* 容器内部将不再拥有所有的端口资源，原因是部分端口资源已经被宿主机本身的服务占用，还有部分端口已经用以bridge网络模式容器的端口映射

* 如果两个以上的容器都加入host模式的网络，就无法监听同一端口，会发生访问冲突

* host模式的网络只可以创建一个

* 容器一旦加入host模式的网络，就无法通过网络管理指令来断开或连接网络

### 4、overlay模式
```
docker network create -d overlay overlay_network
```

overlay模式的网络需要手动创建，区别于以上三种模式，它主要用于对集群的管理和服务（假设有三台主机）：

* 第一台主机作为swarn管理节点
```
docker swarm init
```

截图如下：

<div align=left><img width="80%" height="80%" src="https://github.com/ffeiDing/OS-Practice/blob/master/hw3/overlay模式管理节点.png"/></div>

* 第二台和第三台主机作为普通节点加入
```
root@oo-lab:/home/pkusei# docker swarm join \
> --token SWMTKN-1-5lod92o32eiq84x5uy26dhszode6zx8pdpj30k85xq1s167pdg-e5li4l6jnd0zjf9j7vg2w3z5g \
> 172.16.6.213:2377
```
截图如下：

<div align=left><img width="80%" height="80%" src="https://github.com/ffeiDing/OS-Practice/blob/master/hw3/overlay模式普通节点.png"/></div>

* 第一台主机（管理节点）查看所有节点
```
docker node ls
```
截图如下：

<div align=left><img width="80%" height="80%" src="https://github.com/ffeiDing/OS-Practice/blob/master/hw3/overlay节点.png"/></div>

* 每台主机都可以通过<code>docker network ls</code>指令看到overlay模式的网络
<div align=left><img width="80%" height="80%" src="https://github.com/ffeiDing/OS-Practice/blob/master/hw3/overlay模式网络.png"/></div>

* 输入<code>docker network create -d overlay overlay_network</code>指令手动创建overlay网络

* 采用如下指令创建容器，此时不能创建普通容器，需要创建一个docker server用于集群，并创建三个task，将管理容器中的80端口映射到宿主机的8888端口
```
docker service create --replicas 3 --network overlay_network --name overlay_web -p 8888:80 nginx
```
* 登录燕云，添加管理容器所在的主机8888端口至宿主机8888端口的端口转发

* 浏览器访问<code>http://162.105.174.40:8888</code>
<div align=left><img width="80%" height="80%" src="https://github.com/ffeiDing/OS-Practice/blob/master/hw3/overlay访问web.png"/></div>

## 五、阅读mesos中负责与docker交互的代码

代码位于<code>mesos-1.1.0/src/docker</code>文件夹中，有<code>docker.cpp</code>、<code>docker.hpp</code>、<code>executor.cpp</code>、<code>executor.hpp</code>和<code>spec.cpp</code>五个文件。

### 1、 <code>docker.cpp</code>、<code>docker.hpp</code>

 <code>docker.hpp</code>头文件中定义了Docker类，该类内部又定义了Container（容器）和Image（镜像）两个类。<code>docker.cpp</code>文件实现了Docker类中的成员函数，主要负责将参数与docker指令一一对应。比较重要的函数有<code>create</code>：创建容器或者创建镜像，<code>run</code>：运行docker，<code>stop</code>：停止运行docker，<code>kill</code>：杀死docker，<code>rm</code>：删除docker等等，其中<code>run</code>函数具体实现如下：

* 首先获取docker的信息
```
const ContainerInfo::DockerInfo& dockerInfo = containerInfo.docker();
```

* 添加路径、-H选项、socket参数和run命令
```
vector<string> argv;
argv.push_back(path);
argv.push_back("-H");
argv.push_back(socket);
argv.push_back("run");
```

* 检查是否有特权，如果有添加--privileged参数
```
if (dockerInfo.privileged()) {
    argv.push_back("--privileged");
}
```

* 检查资源分配情况，添加--cpu-shares、--memory参数

* 检查环境变量，添加环境变量参数
```
if (env.isSome()) {
    foreachpair (string key, string value, env.get()) {
    argv.push_back("-e");
    argv.push_back(key + "=" + value);
    }
}
```

* 检查并添加commandInfo中的环境变量参数


* 手动添加MESOS_SANDBOX和MESOS_CONTAINER_NAME环境变量参数
```
argv.push_back("-e");
argv.push_back("MESOS_SANDBOX=" + mappedDirectory);
argv.push_back("-e");
argv.push_back("MESOS_CONTAINER_NAME=" + name);
```

* 配置volume

* 配置网络（host、bridge、none模式和用户自定义模式），并检查相关模式下的配置是否有错误，比如host和none模式下不能进行端口映射等

* 检查并添加外部设备参数

* 如果shell被激活，重写entrypoint
```
if (commandInfo.shell()) {
    argv.push_back("--entrypoint");
    argv.push_back("/bin/sh");
}
```

* 添加容器名和镜像名
```
argv.push_back("--name");
argv.push_back(name);
argv.push_back(image);
```

* 创建子进程运行容器
```
Try<Subprocess> s = subprocess(
    path,
    argv,
    Subprocess::PATH("/dev/null"),
    _stdout,
    _stderr,
    nullptr,
    environment);
```

### 2、<code>executor.cpp</code>、<code>executor.hpp</code>

该部分实现了一个执行docker的executor，将docker作为一个task，对它进行注册、启动、运行、终止等基本操作。

### 3、<code>spec.cpp</code>
该文件负责解析JSON格式的配置文件，解析为map类。

## 五、写一个framework，以容器的方式运行task
```
./bin/mesos-agent.sh --master=172.16.6.213:5050 --work_dir=/var/lib/mesos \
--ip=172.16.6.224 --hostname=162.105.174.40 --containerizers=docker,mesos \
--image_providers=docker --isolation=docker/runtime

./bin/mesos-master.sh --ip=172.16.6.213 --hostname=162.105.174.40 --work_dir=/var/lib/mesos

python DockerScheduler.py 172.16.6.213 &
```
## 四、Mesos资源调度算法
### 1、我对DRF算法的理解
* Mesos默认的资源调度算法是DRF（主导资源公平算法 Dominant Resource Fairness），它是一种支持多资源的最大-最小公平分配机制。类似网络拥塞时带宽的分配，在公平的基础上，尽可能满足更大的需求。但Mesos更为复杂一些，因为有主导资源（支配性资源）的存在。比如假设系统中有9个CPU，18GB RAM，A用户请求的资源为（1 CPU, 4 GB），B用户请求的资源为（3 CPU， 1 GB），那么A的支配性资源为内存（CPU占比1/9，内存占比4/18），B的支配性资源为CPU（CPU占比3/9，内存占比1/18）。
* DRF算法的目标是使每个用户获得相同比例的支配性资源，给A用户（3 CPU，12 GB），B用户（6 CPU，2 GB），这样A获得了2/3的内存资源，B获得了2/3的CPU资源。
* DRF鼓励用户去共享资源，如果资源是在用户之间被平均地切分，会保证没有用户会拿到更多资源。
* DRF是strategy-proof，即用户不能通过欺骗来获取更多地资源分配。
* DRF是envy-free（非嫉妒）的，没有一个用户会与其他用户交换资源分配。
* DRF分配是Pareto efficient，即不可能通过减少一个用户的资源分配来提升另一个用户的资源分配。
### 2、在源码中的位置
DRF算法的源码位于mesos-1.1.0/src/master/allocator/sorter/drf文件夹中，其中的sorter.cpp用来对framework进行排序、add、remove、update等操作。mesos-1.1.0/src/master/allocator/mesos/hierarchical.cpp文件是分层分配器，它调用了sorter.cpp和sorter.hpp进行功能上的具体实现。

## 五、写一个完成简单工作的框架

使用python语言，扩展了豆瓣的pymesos/examples文件夹下的scheduler.py和executor.py，使用蒙特卡洛法计算π的值。

蒙特卡洛算法是通过概率来计算π的值的。对于一个单位为1的正方形，以其某一个顶点为圆心，边为半径在正方形内画扇形（一个1/4的圆形的扇形），那么扇形的面积就是π/4。这样，利用概率的方式，“随机”往正方形里面放入一些“点”，根据这些点在扇形内的概率（在扇形内的点数/投的总点数）计算出π的值。

