# 第三次作业
## 一、安装配置Docker

安装成功后，docker服务端和docker客户端版本信息如下图：

<div align=left><img width="50%" height="50%" src="https://github.com/ffeiDing/OS-Practice/blob/master/hw3/docker版本信息截图.png"/></div>

## 二、docker基本命令
### 1、镜像管理
* 列出镜像 
```
docker images [OPTIONS] [REPOSITORY]
参数:
-a, --all=false                  列出所有镜像（默认隐藏中间镜像）
--digests=falseShow digests      摘要
-f, --filter=[]                  根据条件过滤输出
--help=false                     打印使用帮助
--no-trunc=false                 不缩略输出          
-q, --quiet=false                仅显示数字标识符
```
>例子：
```
docker images
```
<div align=left><img width="80%" height="80%" src="https://github.com/ffeiDing/OS-Practice/blob/master/hw3/dockerimages指令运行截图.png"/></div>  

* 拉取镜像
```
docker pull [OPTIONS] NAME[:TAG|@DIGEST]
参数:
-a, --all-tags=false             拉取所有tagged镜像 
--help=false                     打印使用帮助
```
>例子：
```
docker pull  ubuntu:latest
docker pull  ubuntu:12.04
```
<div align=left><img width="80%" height="80%" src="https://github.com/ffeiDing/OS-Practice/blob/master/hw3/dockerpull指令运行截图.png"/></div> 

* 查找镜像
```
docker search [OPTIONS] TERM/NAME
参数:
--automated=false             仅显示自动化的builds
--help=false                  打印使用帮助
--no-trunc=false              不缩略输出 
-s, --stars=0                 只显示至少x颗星的信息（在该情况下为至少0颗星）
```
>例子：
```
docker search hello_world
```
<div align=left><img width="80%" height="80%" src="https://github.com/ffeiDing/OS-Practice/blob/master/hw3/dockersearch指令运行截图.png"/></div> 

* 构建镜像

Step 1:建立Dockerfile
```
FROM ubuntu
MAINTAINER zxp huo "likewind@gmail.com"
RUN apt-get update
RUN apt-get install -y nginx
RUN echo 'hi ,i am in container'>/usr/share/nginx/html/index.html
EXPOSE 80
```
Step 2:build建立镜像
```
docker build [OPTIONS] PATH | URL | -
参数:
-c, --cpu-shares=0    CPU shares (relative weight)
--cpuset-cpus=        CPUs in which to allow execution 
-f, --file=           Name of the Dockerfile (Default is 'PATH/Dockerfile')
--force-rm=false      Always remove intermediate containers
--help=false          Print usage
-m, --memory=         Memory limit
--memory-swap=        Total memory (memory + swap), '-1' to disable swap
--no-cache=false      Do not use cache when building the image
--pull=false          Always attempt to pull a newer version of the image
-q, --quiet=false     Suppress the verbose output generated by the containers
--rm=true             Remove intermediate containers after a successful build
-t, --tag=            Repository name (and optionally a tag) for the image(镜像名：标签)
```

### 2、容器管理

* 创建并启动容器
```
docker run [OPTIONS] IMAGE {COMMAND} [ARG...]
参数:
-d                            创建一个守护式容器在后台运行
-i                            交互式运行
-t                            为容器重新分配一个伪输入终端
-p                            指定端口或IP进行映射
--name="NAME"                 为容器指定一个名称
--network="NETWORK_NAME"      选择一个网络
```
* 查看容器
```
docker ps [OPTIONS]
参数:
-a                            查看已经创建的容器
-s                            查看已经启动的容器
```
* 启动容器
```
docker start con_name         启动容器名为con_name的容器
```
* 停止运行容器
```
docker stop con_name          停止容器名为con_name的容器
```
* 删除容器
```
docker rm con_name            删除容器名为con_name的容器
```
* 重命名容器
```
docker rename old_name new_name
```
* 容器信息
```
docker logs con_name          获取容器名为con_name的容器日志
```

### 3、网络管理
* 创建网络
```
docker network create
```
* 容器连接到网络
```
docker network connect
```
* 列出网络
```
docker network ls
```
* 删除网络
```
docker network rm
```
* 容器断开网络
```
docker network disconnect
```
* 网络信息
```
docker network inspect
```

## 三、创建一个基础镜像为ubuntu的docker镜像，随后在其中加入nginx服务器，之后启动nginx服务器并利用tail命令将访问日志输出到标准输出流。要求该镜像中的web服务器主页显示自己编辑的内容，编辑的内容包含学号和姓名。之后创建一个自己定义的network，模式为bridge，并让自己配的web服务器容器连到这一网络中。要求容器所在宿主机可以访问这个web服务器搭的网站
### 1、创建一个基础镜像为ubuntu的docker镜像
* 拉取镜像
```
sudo docker pull  ubuntu:latest
```
<div align=left><img width="80%" height="80%" src="https://github.com/ffeiDing/OS-Practice/blob/master/hw3/dockerpull指令运行截图.png"/></div> 

* 创建并启动容器
```
docker run -i -t --name ubuntu_docker -p 9999:80 ubuntu /bin/bash
```
### 2、加入nginx服务器

* 在创建的容器中安装ngix
```
apt update
apt install nginx
```
* 安装依赖包
```
apt install vim
```
* 修改主页内容
```
cd /var/www/html/
vim index.nginx-debian.html
```
* 添加转发端口号

登录燕云，添加内部9999端口至外部9999端口的转发

<div align=left><img width="80%" height="80%" src="https://github.com/ffeiDing/OS-Practice/blob/master/hw3/添加端口.png"/></div> 

* 启动nginx服务器
```
cd ..
cd ..
cd ..
nginx
```
* 浏览器访问<code> http://162.105.174.40:9999 </code>查看主页内容

<div align=left><img width="80%" height="80%" src="https://github.com/ffeiDing/OS-Practice/blob/master/hw3/web主页内容.png"/></div>

* 输出访问日志到标准输出流
```
tail -f /var/log/nginx/access.log
```
结果如下图：

<div align=left><img width="100%" height="100%" src="https://github.com/ffeiDing/OS-Practice/blob/master/hw3/访问日志.png"/></div>

### 3、创建自定义网络

* 停止容器

Ctrl C 后退回到容器
```
exit
```
停止该容器

* 保存镜像
```
docker commit ubuntu_docker ubuntu_docker2
```
* 创建并运行带新镜像的容器
```
docker run -d --name hw_docker -p 9999:80 ubuntu_docker2 nginx -g 'daemon off;'
```
* 创建一个自己定义的network，模式为bridge
```
docker network create hw_network
```
* 将容器连入网络并检查
```
docker network connect hw_network hw_docker
docker network inspect hw_network
```
下图表示成功连入

<div align=left><img width="80%" height="80%" src="https://github.com/ffeiDing/OS-Practice/blob/master/hw3/网络信息.png"/></div>

### 4、宿主机访问web服务器搭的网站

* 查看容器信息获取ip地址
```
docker inspect hw_docker
```

ip地址为172.17.0.2

* 访问web服务器网站
```
curl 172.17.0.2:80
```
<div align=left><img width="80%" height="80%" src="https://github.com/ffeiDing/OS-Practice/blob/master/hw3/访问web服务器搭的网站.png"/></div>

## 四、docker容器加入不同的网络模式
### 1、null模式
```
docker run -i -t --net="none"  mysql:latest /bin/bash
```

输入以上指令进入容器后，再输入<code>ip addr</code>，查看网络信息
<div align=left><img width="80%" height="80%" src="https://github.com/ffeiDing/OS-Practice/blob/master/hw3/null模式网络.png"/></div>

* 容器仅有一个本地回环网络<code>127.0.0.1</code>，没有任何网络配置

* 容器不能通过网络管理指令来断开null模式下的网络

### 2、bridge模式
```
docker run -i -t mysql:latest /bin/bash
docker run -i -t --net="bridge" mysql:latest /bin/bash
```

以上两个指令都可以创建bridge模式的网络下的容器，即默认情况下容器的网络配置为bridge模式，进入容器后，再输入<code>ip addr</code>，查看网络信息
<div align=left><img width="80%" height="80%" src="https://github.com/ffeiDing/OS-Practice/blob/master/hw3/bridge模式网络.png"/></div>

从上图中可以看到，容器内有一个eth0接口，解释eth0需要理解bridge桥接模式：

* Docker Daemon利用veth pair技术，在宿主机上创建两个虚拟网络接口设备，假设为veth0和veth1。veth pair技术的特性可以保证无论哪一个veth接收到网络报文，都会将报文传输给另一方

* Docker Daemon将veth0附加到Docker Daemon创建的docker0网桥上，保证宿主机的网络报文可以发往veth0

* Docker Daemon将veth1添加到容器所属的<code>namespace</code>下，并被改名为eth0。

* 宿主机的网络报文若发往veth0，则立即会被eth0接收，实现宿主机到容器网络的联通性；同时，也保证Docker Container单独使用eth0，实现容器网络环境的隔离性

* bridge模式的网络可以创建多个

* 容器可以通过网络管理指令来断开bridge模式下的网络或连接其他网络

### 3、host模式
```
docker run -i -t --net="host" mysql:latest /bin/bash
```

该模式区别于bridge模式，在无需进行NAT转换的同时，隔离性弱化了：

* 容器不需要通过桥接模式，可以直接访问宿主机上的全部网络信息，不会有所属的<code>namespace</code>，而是共享宿主机的<code>namespace</code>

* 容器内部将不再拥有所有的端口资源，原因是部分端口资源已经被宿主机本身的服务占用，还有部分端口已经用以bridge网络模式容器的端口映射

* 如果两个以上的容器都加入host模式的网络，就无法监听同一端口，会发生访问冲突

* host模式的网络只可以创建一个

* 容器一旦加入host模式的网络，就无法通过网络管理指令来断开或连接网络

### 4、overlay模式

## 四、Mesos资源调度算法
### 1、我对DRF算法的理解
* Mesos默认的资源调度算法是DRF（主导资源公平算法 Dominant Resource Fairness），它是一种支持多资源的最大-最小公平分配机制。类似网络拥塞时带宽的分配，在公平的基础上，尽可能满足更大的需求。但Mesos更为复杂一些，因为有主导资源（支配性资源）的存在。比如假设系统中有9个CPU，18GB RAM，A用户请求的资源为（1 CPU, 4 GB），B用户请求的资源为（3 CPU， 1 GB），那么A的支配性资源为内存（CPU占比1/9，内存占比4/18），B的支配性资源为CPU（CPU占比3/9，内存占比1/18）。
* DRF算法的目标是使每个用户获得相同比例的支配性资源，给A用户（3 CPU，12 GB），B用户（6 CPU，2 GB），这样A获得了2/3的内存资源，B获得了2/3的CPU资源。
* DRF鼓励用户去共享资源，如果资源是在用户之间被平均地切分，会保证没有用户会拿到更多资源。
* DRF是strategy-proof，即用户不能通过欺骗来获取更多地资源分配。
* DRF是envy-free（非嫉妒）的，没有一个用户会与其他用户交换资源分配。
* DRF分配是Pareto efficient，即不可能通过减少一个用户的资源分配来提升另一个用户的资源分配。
### 2、在源码中的位置
DRF算法的源码位于mesos-1.1.0/src/master/allocator/sorter/drf文件夹中，其中的sorter.cpp用来对framework进行排序、add、remove、update等操作。mesos-1.1.0/src/master/allocator/mesos/hierarchical.cpp文件是分层分配器，它调用了sorter.cpp和sorter.hpp进行功能上的具体实现。

## 五、写一个完成简单工作的框架

使用python语言，扩展了豆瓣的pymesos/examples文件夹下的scheduler.py和executor.py，使用蒙特卡洛法计算π的值。

蒙特卡洛算法是通过概率来计算π的值的。对于一个单位为1的正方形，以其某一个顶点为圆心，边为半径在正方形内画扇形（一个1/4的圆形的扇形），那么扇形的面积就是π/4。这样，利用概率的方式，“随机”往正方形里面放入一些“点”，根据这些点在扇形内的概率（在扇形内的点数/投的总点数）计算出π的值。

本程序中共随机了20*200000次。

Pi_scheduler.py文件如下：
```
#!/usr/bin/env python2.7
from __future__ import print_function

import sys
import uuid
import time
import socket
import signal
import getpass
from threading import Thread
from os.path import abspath, join, dirname

from pymesos import MesosSchedulerDriver, Scheduler, encode_data, decode_data
from addict import Dict

TASK_CPU = 1
TASK_MEM = 32
EXECUTOR_CPUS = 0.5
EXECUTOR_MEM = 32


class PiScheduler(Scheduler):
    # 初始化一些变量
    Pi = 0
    sumPi = 0
    count = 20
    i = 0
    temp = 0
    nums = 2000000

    def __init__(self, executor):
        self.executor = executor

    # 计算Pi的值，判断何时停止运行
    def frameworkMessage(self, driver, executorId, slaveId, message):
        self.sumPi = self.sumPi + float(decode_data(message))
        self.temp = self.temp + 1
        if self.temp >= self.count:
            self.Pi = self.sumPi/self.count
            print(self.Pi)
            driver.stop()

    def resourceOffers(self, driver, offers):
        if self.i >= self.count:
            return None
        filters = {'refuse_seconds': 5}

        for offer in offers:
            if self.i >= self.count:
                break
            cpus = self.getResource(offer.resources, 'cpus')
            mem = self.getResource(offer.resources, 'mem')
            if cpus < TASK_CPU or mem < TASK_MEM:
                continue

            task = Dict()
            task_id = str(uuid.uuid4())
            task.task_id.value = task_id
            task.agent_id.value = offer.agent_id.value
            task.name = 'task {}'.format(task_id)
            task.executor = self.executor
            # 保留以作测试用 ：）
            task.data = encode_data('Hello from task {}!'.format(task_id))

            task.resources = [
                dict(name='cpus', type='SCALAR', scalar={'value': TASK_CPU}),
                dict(name='mem', type='SCALAR', scalar={'value': TASK_MEM}),
            ]

            driver.launchTasks(offer.id, [task], filters)
            self.i = self.i + 1

    def getResource(self, res, name):
        for r in res:
            if r.name == name:
                return r.scalar.value
        return 0.0

    def statusUpdate(self, driver, update):
        logging.debug('Status update TID %s %s',
                      update.task_id.value,
                      update.state)


def main(master):
    executor = Dict()
    executor.executor_id.value = 'PiExecutor'
    executor.name = executor.executor_id.value
    executor.command.value = '%s %s' % (
        sys.executable,
        abspath(join(dirname(__file__), 'executor.py'))
    )
    executor.resources = [
        dict(name='mem', type='SCALAR', scalar={'value': EXECUTOR_MEM}),
        dict(name='cpus', type='SCALAR', scalar={'value': EXECUTOR_CPUS}),
    ]

    framework = Dict()
    framework.user = getpass.getuser()
    framework.name = "PiFramework"
    framework.hostname = socket.gethostname()

    driver = MesosSchedulerDriver(
        PiScheduler(executor),
        framework,
        master,
        use_addict=True,
    )

    def signal_handler(signal, frame):
        driver.stop()

    def run_driver_thread():
        driver.run()

    driver_thread = Thread(target=run_driver_thread, args=())
    driver_thread.start()

    print('Scheduler running, wait :).')
    signal.signal(signal.SIGINT, signal_handler)

    while driver_thread.is_alive():
        time.sleep(1)


if __name__ == '__main__':
    import logging
    logging.basicConfig(level=logging.DEBUG)
    if len(sys.argv) != 2:
        print("Usage: {} <mesos_master>".format(sys.argv[0]))
        sys.exit(1)
    else:
        main(sys.argv[1])
```

其中，和样例的主要差别在于：
```
 # 计算Pi的值，判断何时停止运行
    def frameworkMessage(self, driver, executorId, slaveId, message):
        self.sumPi = self.sumPi + float(decode_data(message))
        self.temp = self.temp + 1
        if self.temp >= self.count:
            self.Pi = self.sumPi/self.count
            print(self.Pi)
            driver.stop()
```

样例不会主动停止运行，可以通过调用API让程序自动终止，并打印出最终结果。

Pi_executor.py文件如下：
```
#!/usr/bin/env python2.7
from __future__ import print_function

import sys
from random import random
import time
from threading import Thread

from pymesos import MesosExecutorDriver, Executor, decode_data, encode_data
from addict import Dict


class PiExecutor(Executor):
    def launchTask(self, driver, task):
        def run_task(task):
            update = Dict()
            update.task_id.value = task.task_id.value
            update.state = 'TASK_RUNNING'
            update.timestamp = time.time()
            driver.sendStatusUpdate(update)

            # 保留以作测试用
            print(decode_data(task.data), file=sys.stderr)
            cnt = 0 
            N = 2000000
            for i in range(N) :  
                x = random()
                y = random()
                if (x*x + y*y) < 1 :  
                    cnt += 1  
            vPi = 4.0 * cnt / N 
            print(vPi)
            driver.sendFrameworkMessage(encode_data(str(vPi)))

            time.sleep(30)

            update = Dict()
            update.task_id.value = task.task_id.value
            update.state = 'TASK_FINISHED'
            update.timestamp = time.time()
            driver.sendStatusUpdate(update)

        thread = Thread(target=run_task, args=(task,))
        thread.start()


if __name__ == '__main__':
    import logging
    logging.basicConfig(level=logging.DEBUG)
    driver = MesosExecutorDriver(PiExecutor(), use_addict=True)
    driver.run()
```

其中，和样例的主要差别在于：
```
            # 具体程序
            cnt = 0 
            N = 2000000
            for i in range(N) :  
                x = random()
                y = random()
                if (x*x + y*y) < 1 :  
                    cnt += 1  
            vPi = 4.0 * cnt / N 
            print(vPi)
            driver.sendFrameworkMessage(encode_data(str(vPi)))
```

样例仅仅是简单输出了“Hello from task...”，此处需要修改为计算Pi值的具体程序，并将单次计算结果封装传递。

运行结果截图如下，可以看到计算出的π的结果3.1414582，还是比较接近原值的，如果加大数据量，结果应该会更加准确：
<div align=center><img width="75%" height="75%" src="https://github.com/ffeiDing/OS-Practice/blob/master/hw2/运行结果截图.png"/></div>

资源使用情况如下：
<div align=center><img width="30%" height="30%" src="https://github.com/ffeiDing/OS-Practice/blob/master/hw2/资源使用情况截图.png"/></div>

